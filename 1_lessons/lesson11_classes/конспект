# Объектно-ориентированное программирование в Python

## 1. Определение классов

Класс в Python — это шаблон или чертеж, который определяет характеристики и поведение для создаваемых объектов. Класс объединяет данные (атрибуты) и функциональность (методы) в одну структуру.

```python
class Group:  # класс родитель
    students = True  # атрибут класса - все группы имеют студентов
    shcool_number = 42  # атрибут класса - номер школы
    director = 'Marivanna'  # атрибут класса - директор
    
    def __init__(self, title, student_count, group_lider):
        # Конструктор, который вызывается при создании объекта
        self.title = title  # атрибут экземпляра - название группы
        self.student_count = student_count  # атрибут экземпляра - количество студентов
        self.group_lider = group_lider  # атрибут экземпляра - лидер группы

    def study(self):  # метод класса - действие, которое может выполнять группа
        print('study')  # вывод сообщения "study"
```

**Понимание студента:**
> "Класс это шаблон или сборище данных по которым создаются подклассы и откуда наследуются определенные характеристики, методы и т.д. Класс определяется по типу `class ClassName:`. На сколько я понял, чтобы создавать как бы иерархию переменных и методов - чтобы у нас была главная ступень, от нее отходили другие, которые наследуют что-то от главной ступени."

## 2. Атрибуты класса

Атрибуты класса - это переменные, которые определены внутри класса, но вне методов. Они принадлежат самому классу, а не его экземплярам, то есть являются общими для всех объектов этого класса.

```python
class Phone:
    invented_year = 1876  # Год изобретения телефона
    inventor = "Alexander Graham Bell"  # Изобретатель телефона
    types = ['Landline', 'Mobile', 'Smartphone']  # Типы телефонов

# Пример использования
my_phone = Phone()  # Создание экземпляра
print(Phone.invented_year)  # 1876
print(my_phone.inventor)  # "Alexander Graham Bell"

# Изменение через класс
Phone.invented_year = 1877
print(my_phone.invented_year)  # 1877 - изменилось для всех экземпляров

# Изменение через экземпляр
my_phone.invented_year = 1878
print(my_phone.invented_year)  # 1878 - изменилось только для этого экземпляра
print(Phone.invented_year)     # 1877 - для класса и других экземпляров не изменилось
```

**Понимание студента:**
> "Атрибуты класса это какие-то характеристики присущие этому классу. Если мы меняем атрибут через класс (`Class.attribute = change`), то он меняется для всех экземпляров, а если мы меняем его через конкретный экземпляр (`example.attribute = change`), тогда меняется только для конкретного экземпляра."

## 3. Методы класса и параметр self

Методы класса - это функции, определенные внутри класса. Они определяют поведение объектов класса. Параметр `self` - это ссылка на конкретный экземпляр класса, для которого вызывается метод.

```python
class Cat:
    def __init__(self, name):
        # self - это только что созданная кошка
        self.name = name  # Сохраняем имя в этой конкретной кошке
    
    def meow(self):
        # self - это кошка, которая мяукает
        print(f"{self.name}: Мяу!")

# Создаем две разные кошки
cat1 = Cat("Барсик")  # __init__(cat1, "Барсик")
cat2 = Cat("Мурка")   # __init__(cat2, "Мурка")

# Заставляем их мяукать
cat1.meow()  # meow(cat1) -> "Барсик: Мяу!"
cat2.meow()  # meow(cat2) -> "Мурка: Мяу!"
```

**Понимание студента:**
> "Self это просто переменная, которая определяет кто ее вызывает и от этого уже делает что-то определенное. Аргумент любого объекта попадает в self в __init__ в любом случае при создании, а потом уже при вызове какого-то метода так же этот аргумент попадает в self этого метода."

## 4. Наследование классов

Наследование — один из основных принципов ООП, который позволяет создавать новый класс на основе существующего. Класс-наследник получает все атрибуты и методы родительского класса и может добавлять свои собственные или переопределять существующие.

```python
class Device:
    def __init__(self, name):
        self.name = name  # Имя устройства

    def power_on(self):
        print(f'{self.name} включено')  # Сообщение о включении

class SmartPhone(Device):  # Наследуется от Device
    def make_call(self, number):  # Новый метод
        print(f'Звоню по номеру {number}')  # Сообщение о звонке

# Создаем смартфон
iphone = SmartPhone('iphone')

# Вызываем метод, унаследованный от Device
iphone.power_on()  # "iphone включено"

# Вызываем метод, определенный в SmartPhone
iphone.make_call(89889905968)  # "Звоню по номеру 89889905968"
```

**Понимание студента:**
> "Наследование это передача определенных характеристик (качеств) от главного класса к подклассу. Нужно для наследования, чтобы можно было создавать иерархию чего-либо (методов, классов, элементов и т.д.)."

## 5. Переопределение методов в наследовании

Классы-наследники могут переопределять методы родительского класса, предоставляя свою реализацию. Это позволяет изменить поведение метода для конкретного подкласса.

```python
class Animal:
    def __init__(self, name):
        self.name = name  # Имя животного

    def speak(self):
        print(f'{self.name} издает звук')  # Базовый метод

class Dog(Animal):  # Наследование от Animal
    def speak(self):
        print(f'{self.name} издает звук гав')  # Переопределение метода

class Cat(Animal):  # Наследование от Animal
    def speak(self):
        print(f'{self.name} издает звук мяу')  # Переопределение метода

# Создаем животных
dog1 = Dog('Бобик')
cat1 = Cat('Мурка')

# Вызываем переопределенные методы
dog1.speak()  # "Бобик издает звук гав"
cat1.speak()  # "Мурка издает звук мяу"
```

**Понимание студента:**
> "Переопределение методов - это изменение наследованных действий (методов) от родительского класса."

## 6. Использование функции super()

Функция `super()` используется для вызова методов родительского класса. Это особенно полезно, когда вы хотите расширить функциональность метода родителя, а не полностью заменить его.

```python
class Animal:
    def __init__(self, name):
        self.name = name  # Имя животного

    def sound(self, name):  # Метод принимает параметр name
        print(f'{self.name} издает звук')  # Базовый метод

class Dog(Animal):
    def sound(self):
       super().sound(self.name)  # Вызываем метод родителя с передачей name
       print(f'{self.name} издает звук гав')  # Добавляем специфику собаки

# Создаем собаку
dog1 = Dog('Бобик')

# Вызываем метод
dog1.sound()
# Выведет:
# Бобик издает звук
# Бобик издает звук гав
```

**Понимание студента:**
> "Super() вызывает родительский метод в дочернем. В первом случае (конструкторы) мы добавляем новый параметр/аргумент, а во втором (обычные методы) мы добавляем действие. Если в родительском методе есть параметры (помимо self), то при вызове через super() эти параметры нужно передавать."

## 7. Абстрактные методы и классы

Абстрактные методы - это методы, которые объявлены, но не имеют реализации в базовом классе. Они должны быть реализованы в классах-наследниках. Абстрактный класс - это класс, который содержит хотя бы один абстрактный метод.

```python
from abc import ABC, abstractmethod

class Employee(ABC):  # Абстрактный класс сотрудника
    def __init__(self, name, position):
        self.name = name  # Имя сотрудника
        self.position = position  # Должность

    @abstractmethod  # Абстрактный метод расчета зарплаты
    def calculate_salary(self):
        pass  # Метод без реализации

class HourlyEmployee(Employee):  # Почасовой сотрудник
    def __init__(self, name, position, hourly_rate, hours_worker):
        super().__init__(name, position)  # Вызываем конструктор родителя
        self.hourly_rate = hourly_rate  # Часовая ставка
        self.hours_worker = hours_worker  # Отработанные часы

    def calculate_salary(self):  # Реализация абстрактного метода
        print(f'{self.name} заработал {self.hourly_rate * self.hours_worker} рублей')

# Создаем сотрудника
Egor = HourlyEmployee('Egor', 'Разработчик', 1000, 160)

# Вызываем метод расчета зарплаты
Egor.calculate_salary()  # "Egor заработал 160000 рублей"

# Попытка создать экземпляр абстрактного класса вызовет ошибку
# employee = Employee("Иван", "Менеджер")  # TypeError
```

**Понимание студента:**
> "Абстрактный метод - это метод родительского класа, который ничего не несет в себе, но который создает правило, что этот метод должен быть реализован в дочернем классе. Абстрактный класс - это что-то типа пропущенной ступени эволюции."

## 8. Практическое применение ООП

Принципы ООП позволяют создавать хорошо структурированный, модульный код:

1. **Инкапсуляция** - объединение данных и методов в одной структуре (классе) и скрытие внутренних деталей реализации
2. **Наследование** - создание новых классов на основе существующих
3. **Полиморфизм** - возможность работать с объектами разных классов через общий интерфейс

**Основные преимущества ООП:**
- Повторное использование кода
- Модульность и структурированность
- Легкость расширения и модификации
- Естественное моделирование реального мира

**Типичные примеры использования ООП:**
- Проектирование GUI (графических интерфейсов)
- Разработка игр (персонажи, предметы, сцены)
- Моделирование бизнес-процессов
- Работа с базами данных (ORM-системы)

## 9. Ключевые выводы

- **Классы** - это шаблоны для создания объектов с определенным поведением
- **Атрибуты класса** - общие для всех экземпляров, атрибуты экземпляра - уникальные для каждого объекта
- **Self** - это ссылка на конкретный экземпляр, позволяющая методам работать с нужным объектом
- **Наследование** позволяет создавать иерархии классов и избегать дублирования кода
- **Переопределение методов** дает возможность изменять поведение классов-наследников
- **Super()** обеспечивает доступ к методам родительского класса
- **Абстрактные классы и методы** определяют "контракты", которые должны быть реализованы

Понимание этих принципов позволяет создавать элегантный, гибкий и поддерживаемый код, следуя парадигме объектно-ориентированного программирования.
